#!/usr/bin/env node
'use strict';

var program = require('commander');
var app = require('../');
var rootPath = require('path');
var message = require('../lib/middleware/message');
var watcher = require('watch');
var ngrok = require('../lib/ngrok');
var pathNode = require('path');
var fs = require('fs');
var chalk = require('chalk');
var defValue = {
    port: 3113,
    homepage: 'index',
    isWatching: true,
    files: '*',
    log: false,
    ngrok: false,
    ngrokpath: '/usr/bin/ngrok'
};

var files = [];

program
    .version(message.v());
program
    .command('serve [path]')
    .description('\tRun Node Serve Here')
    .option('-l, --log', 'default is disabled')
    .option('-p, --port <port>', 'startServer port. default port is 3113')
    .option('-m, --main <homepage>', 'index file to start. no extension (html only)')
    .option('-w, --watch', 'watch project root directory for file changes. default is enabled')
    .option('-f, --files <files>','comma separated files extension to watch. default is all file types.')
    .option('-n, --ngrok', 'using ngrok to expose local web server to internet. default is disabled')
    .option('-N, --ngrok-path <ngrokpath>', 'ngrok binary path. default path to /usr/bin/ngrok')
    .option('-s, --subdomain <subdomain>', 'subdomain for ngrok')
    .option('-a, --auth <auth>', 'simple auth for ngrok')
    .action(function (path, program) {
       
        if (!process.argv.slice(3).length) {
            program.help();
        }

        path === '.' ? path = rootPath.resolve('.') : path;

        var projectPath = rootPath.resolve(process.cwd(), path || '');
        var port = program.port || defValue.port;
        var homepage = program.main || defValue.homepage;
        var isWatching = program.watch || defValue.isWatching;
        var log = program.log || defValue.log;
        var useNgrok = program.ngrok || defValue.ngrok;
        var ngrokPath = program.ngrokpath || defValue.ngrokpath;
        var subdomain = program.subdomain || null;
        var auth = program.auth || '';
        var filter = program.files || defValue.files;
        var options = {
            port: port,
            homepage: homepage,
            log: log
        }
        var svh = null;
        var ngrokOptions;
        var validFileChanged = false;

        message.version();

        if (useNgrok) {
            ngrokOptions = {
                'ngrokpath':ngrokPath,
                'port': port,
                'subdomain': subdomain,
                'auth': auth,
                'configdir': projectPath
            };
            ngrok.expose(ngrokOptions);
        }

        if (isWatching) {
            var watcherOptions = {
                ignoreDotFiles: true,
                ignoreUnreadableDir: true
            };

            watcher.watchTree(path, watcherOptions, function (f, curr, prev) {
                if(filter === "*"){
                        validFileChanged = true;
                } else{
                    if (typeof f == 'object' && prev === null && curr === null) {
                        
                        console.log('[Watch]');
                        Object.keys(f).forEach(function(name) {
                            var stat = f[name];
                            filesToWatch(name, stat, filter);
                        });
                        validFileChanged = true;
                    } else if (prev === null) {
                        // new file
                        var newFile = fs.statSync(f);
                        var extNewFile = pathNode.extname(f).split('.');

                        if(newFile['size'] == 0) { 
                            validFileChanged = false;
                            // save file path to files to watch if ext is on filter
                            if(extNewFile.length > 1) {
                                var extExistOnFilter = filter.split(',').indexOf(extNewFile[1]);
                                if( extExistOnFilter != -1) { 
                                    files.push(f);
                                }
                            }                            
                        } else {
                            // check extension
                            if(extNewFile.length > 1) {
                                var extExistOnFilter = filter.split(',').indexOf(extNewFile[1]);
                                if( extExistOnFilter != -1) { 
                                    files.push(f);
                                    validFileChanged = true;
                                } else { 
                                    validFileChanged = false;
                                }    
                            } else {
                                validFileChanged = false;
                            }
                        }
                    } else if (curr.nlink === 0) {
                        // f was removed so should removed file from files array
                        var removedFile = files.indexOf(f);
                        if(removedFile != -1) {
                            files.splice(removedFile, 1);
                            validFileChanged = true;
                        } else {
                            validFileChanged = false;   
                        }
                    } else {
                        var exist = files.indexOf(f);
                        (exist != -1) ? validFileChanged = true : validFileChanged = false;         
                    }
                }

                if(validFileChanged){
                    if (svh !== null) {
                        console.log('closing server...');
                        svh.close();
                        console.log('[' + new Date() + '] starting server...');
                        svh = app.server(path, options, callback_server(options.port));
                        app.setReload(true);
                    } else {
                        console.log('[' + new Date() + '] starting server...');
                        svh = app.server(path, options, callback_server(options.port));
                        app.setReload(false);
                    }    
                }
            });
        } else {
            svh = app.server(path, options, callback_server(options.port));
        }
    });

program.parse(process.argv);

if(!process.argv.slice(2).length) {
    program.help();
} else {
    if(process.argv.slice(2)[0] !== 'serve') { 
        program.help();
    } 
}

var callback_server = function (port) {
    console.log('node will serve you at http://localhost:' + port);
};

var filesToWatch = function(f, stat, filter) {
    var ignoreDir = [];
    ignoreDir = f.match(/node_modules/);
    if(!ignoreDir){
        if(filter === "*") return true;
        // push files based on valid files extension to watch
        var ext = pathNode.extname(f).split('.');
        filter.split(',').forEach(function(value){
            if(ext[ext.length - 1] != ''){
                if(ext[ext.length - 1] === value) {
                    console.log(chalk.magenta.bold('- '+f));
                    files.push(f);    
                }
            }    
        })
    }
    return true;
}